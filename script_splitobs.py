#This is the first attempt at creating a general script that will split out individual
# science and calibrator targets into separate measurement sets, for better
# ingestion into the CADC's CAOM2 model.

#This script should be run after running scriptForPI.py to generate calibrated 
# measurement sets.
#Note that this script can be run with SPACESAVING=2 to reduce the number of intermediate
# files saved.  For later versions of CASA (at least using the pipeline for 4.7.0),
# using SPACESAVING=3 will generate problems, as this leaves only a single concatenated
# measurement set, and it is very difficult to split out individual observations of
# the same source after concatenation.

#Note#1: This script requires a version of CASA which includes the 'msmd' (measurement set
# metadata) command.  CASA 4.2.2pipe includes msmd, but casa4.0.1 does not (I am still
# testing versions inbetween these).  There is no problem running scriptForPI.py using
# an older version of CASA (say 4.0.1), and then running this script subsequently with
# a later version of CASA (say 4.3)



####################### Start of the script #####################

#numpy doesn't seem pre-loaded here
import numpy as np

#Part 1: Identify all of the files which have had measurement sets generated for them
# assume a file name format of [uid...].ms.split.cal
# NB for CADC: the set of calibrated measurement sets generated by scriptForPI may be a 
# smaller list than the total number of raw datasets, if some raw datasets failed QA

#assume script lives in /script directory.  Move to where the calibrated data lives.
os.chdir('../calibrated')

os.system('ls -d *.ms.split.cal > ../script/list_of_ms.txt') #generate list of .ms files

#NB: The file name structure should imply that the measurement sets selected 
# have been split after calibration, implying that we wish to keep information
#   in the 'data' column for our additional splitting per target
#   If we need to include files that instead end in .ms, they might have the calibrated info 
#   stored in the 'corrected' column instead.  This subtlety is used for the 'split' command
#   used below.


#Read in the list of calibrated measurement sets one-by-one, pull out target names, and create
# the individual split measurement sets

ms_count = 0
cal_obsnames=[]
cal_targetnames=[]
sci_obsnames=[]
sci_targetnames=[]
with open('../script/list_of_ms.txt') as fp:
	for line in fp:
		line=str.strip(line)	#eliminate trailing hard return
		#print 'Processing '+line
		msmd.open(line)
		#trim the ms.split.cal off of each filename
		line_sho=line[:-13]
		#print 'short version is '+line_sho

		#1) Create a list of all target names for science & calibrator sources.
		#   Note that all science fields have the observing intent 'OBSERVE_TARGET'
		#   All calibrator fields have observing intents of 'CALIBRATE*', however,
		#   sometimes the science fields also have these observing intents
		#   included (e.g., CALIBRATE_WVR)	

		#Identify science fields
		SciFields = msmd.fieldsforintent("OBSERVE_TARGET*",True)
		#Note that sometimes have multiple field numbers for the same field name
		SciFieldsUniq = np.unique(SciFields)
		nscience = len(SciFieldsUniq)

		#Identify calibrator fields
		AllCalFields = msmd.fieldsforintent('CALIBRATE*',True)
		AllCalFieldsUniq = np.unique(AllCalFields)

		#eliminate fields which are also science fields
		CalFieldsUniq=[]
		for s in range(0,len(AllCalFieldsUniq)):
			if AllCalFieldsUniq[s] in SciFieldsUniq:
				#do nothing (debugging output below)
				junk=0
				#print 'found science field'
				#print AllCalFieldsUniq[s]
			else:
				#add field to final Calibrator list
				#print 'found real cal field'
				#print AllCalFieldsUniq[s]
				CalFieldsUniq.append(AllCalFieldsUniq[s])
				#print 'updated final Cal list now says'
				#print CalFieldsUniq


		#Split out the calibrator sources
		print 'Splitting calibrator sources'

		#Loop through each of these fields and split out measurement set
		ncalib = len(CalFieldsUniq)	
		for i in range(0,ncalib):	
			print CalFieldsUniq[i]
			#NB: We may want to consider re-numbering the spectral windows (spw).  
			#  That is not included here - see notes about how to code this at the
			#  bottom of script.
			#eliminate this file if it already exists
			os.system('rm -rf '+line_sho+'.CAL.'+CalFieldsUniq[i]+'.ms.split.cal')
			#split out the calibrator
			split(vis=line,outputvis=line_sho+'.CAL.'+CalFieldsUniq[i]+'.ms.split.cal', field=CalFieldsUniq[i],datacolumn='data')
			#keep track of the target
			cal_obsnames.append(line_sho)
			cal_targetnames.append(CalFieldsUniq[i])


		#Split out the science target(s)
		print 'Splitting science targets'
		for i in range(0,nscience):
			print SciFieldsUniq[i]
			#eliminate the file if it already exists
			os.system('rm -rf '+line_sho+'.SCI.'+SciFieldsUniq[i]+'.ms.split.cal')
			#split out the science target
			split(vis=line,outputvis=line_sho+'.SCI.'+SciFieldsUniq[i]+'.ms.split.cal', field=SciFields[i],datacolumn='data')
			#keep track of the targets
			sci_obsnames.append(line_sho)
			sci_targetnames.append(SciFieldsUniq[i])


		#index the ms counter by 1
		ms_count += 1

		#Finished all splitting
		msmd.done()


################ End of the formal script ##########################

# Note1: The CADC may later wish to concatenate multiple observations of the same target.
# The code below will do that.  In its current form, it would need some of the above
# script to be run, in order to have the arrays of calibrator and science target names
# available.
# Remove one # from each line below to get this to run (comments all have ## in front of them)


##Concatenation script: For simplicity, generate a concatenated file regardless of whether 
## there is 1 or more than 1 observations of each target.

##Combine the calibrators
##get a list of uniqe calibrator names
#uniq_calnames=set(cal_targetnames)
#uniq_calnames=list(uniq_calnames) #make this list index-able
##loop through unique calibrator names, figure out what can be combined
#Ncalnames=len(uniq_calnames)
#for i in range(0,Ncalnames):  
#	#print i, uniq_calnames[i]
#	match = [j for j, x in enumerate(cal_targetnames) if x==uniq_calnames[i]]
#	#print match
#	#Generate a list of split observations from match.  Need to do this one at a time?
#	Nmatch=len(match)
#	use_obsnames=[] #re-set for each loop
#	for j in range(0,Nmatch):
#		use_obsnames.append(cal_obsnames[match[j]]+'.'+uniq_calnames[i]+'.ms.split.cal')
#		print use_obsnames[j]
#
#	#Concatenate the observations
#	print 'Concatenating '+uniq_calnames[i]
#	#!!NB: we probably want a slightly longer, more unique name than I've used.  Perhaps 
#	#include the science goal ous string?
#	#!!!! *** VERY IMPORTANT NOTE ***  The command in the next line will need some tweaks
#	# before it can be generally used.  Frequency tolerances are required to be specified
#	# in order to accurately combine spectral observations for analysis to be run
#	# correctly in the uv plane.  Nienke has thoughts on how to do this correctly.
#	concat(vis=use_obsnames, concatvis=uniq_calnames[i]+'_concat.ms')
#
##Science Targets (same procedure as calibrators)
#uniq_scinames=set(sci_targetnames)
#uniq_scinames=list(uniq_scinames) #make this list index-able
##loop through unique names, figure out what can be combined
#Nscinames=len(uniq_scinames)
#for i in range(0,Nscinames):  
#	#print i, uniq_scinames[i]
#	match = [j for j, x in enumerate(sci_targetnames) if x==uniq_scinames[i]]
#	#print match
#	#Generate a list of observations from match.  Need to do this one at a time?
#	Nmatch=len(match)
#	use_obsnames=[] #re-set for each loop
#	for j in range(0,Nmatch):
#		use_obsnames.append(sci_obsnames[match[j]]+'.'+uniq_scinames[i])
#	#Concatenate files
#	print 'Concatenating '+uniq_scinames[i]
#	#!!NB: probably want a slightly longer, more unique name than I've used.  Perhaps 
#	#include the science goal ous string?
#	concat(vis=use_obsnames, concatvis=uniq_scinames[i]+'_concat.ms')

##ALL DONE!  Splitting and Concatenation finished.



############### A note on extracting metadata #############################
# The 'msmetadata' or 'msmd' command may allow one to access much / all of
# the information CADC needs to extract for the archive listing.  This
# should likely be done on the individual split observations.  See the
# CASA documentation at : 
# https://casa.nrao.edu/casadocs/casa-5.0.0/global-tool-list/tool_msmetadata/about
###########################################################################
		




#################################################################
#Note on re-numbering the spws.  This snippet is copied from scriptForPI.py for 2013.1.00187.S
# and would need a bit of tweaking to work here
#targetspws = msmd.spwsforintent('OBSERVE_TARGET*')
#sciencespws = ''
#outputspws = ''
#i = 0
#for myspw in targetspws:
#    if msmd.nchan(myspw)>4:
#        sciencespws += str(myspw)+','
#        outputspws += str(i)+','
#        i += 1
#sciencespws = sciencespws.rstrip(',')
#outputspws = outputspws.rstrip(',')
#msmd.close()
#print 'Splitting out science SPWs for '+asdmname+': '+sciencespws+' -> '+outputspws
#split(vis=asdmname+'.ms', outputvis=asdmname+'.ms.split.cal', spw = sciencespws)
################################################################
